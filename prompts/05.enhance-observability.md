**Role:** Act as a Senior .NET Backend Developer.
**Task:** Enhancing Observability of the SpaceTracker API and business logic.

use context7.

You are tasked with implementing comprehensive observability improvements for a .NET application. 
The goal is to establish robust monitoring and logging capabilities using OpenTelemetry and native .NET structured logging.

## OpenTelemetry (OTeL) Instrumentation

### Metrics Implementation

Implement the following metrics using OpenTelemetry:

1. **HTTP Endpoint Performance Metrics**
   * Add histogram metrics to track endpoint response times
   * Configure percentile aggregations for P50, P95, and P99
   * Ensure metrics are tagged with endpoint route, HTTP method, and status code

2. **Business Counters**
   * **Trip Processing Counter**: Track the total number of trips processed
   * **Incident Counter**: Track the number of incidents that occurred
     - Add a dimension/label for `incident_severity` to categorize different incidents by their severity type
     - Examples: `incident_severity="Informational"`, `incident_severity="Warning"`, `incident_severity="Catastrophic"`
   * **Event Processing Counter**: Track the total number of events processed by the system
     - Consider adding labels for event type or source if applicable

3. **Technical Requirements**
   * Use `System.Diagnostics.Metrics` API (native .NET)
   * Register metrics with OpenTelemetry MeterProvider
   * Follow naming conventions: use lowercase with underscores (e.g., `trips_processed_total`)
   * Ensure all counters are monotonic and appropriately typed

## Structured Logging Configuration

### Environment-Specific Logging Setup

Configure native .NET structured logging with the following requirements:

1. **Development Environment**
   - Output format: Plain text (human-readable)
   - Destination: Standard output (stdout)

2. **Staging and Production Environments**
   - Output format: JSON (machine-readable)
   - Destination: Standard output (stdout)

3. **Configuration Approach**
   - Use `appsettings.{Environment}.json` for environment-specific settings
   - Leverage `ILogger<T>` dependency injection throughout the application
   - Do not install any third party logging libraries like `Serilog`. Use built in Microsoft.Extensions.Logging for JSON formatting
   - For all environments set IncludeScopes to True.

### Endpoint-Level Logging Scopes

For each API endpoint, implement logging scopes to capture domain entity identifiers:

1. **Scope Implementation**
   - At the beginning of each endpoint handler, create a logging scope with all relevant entity IDs from the request
   - Use `ILogger.BeginScope()` with a dictionary of key-value pairs

2. **Example for Trip Endpoint**
```csharp
   using var tripIdScope =_logger.BeginScope("TripId={TripId}", tripId);
   using var driverIdScope =_logger.BeginScope("DeriverId={DriverId}", request.DriverId);
```

3. **Guidelines**
   - Include all relevant entity IDs that are part of the request (path parameters, query parameters, or request body)
   - Use consistent naming conventions (PascalCase for scope keys)
   - Ensure scopes are properly disposed to avoid memory leaks

### MediatR Pipeline Logging

Implement trace-level logging for MediatR handlers:

1. **Handler Start Log**
   - Format: `"{HandlerName} starts"`
   - Log level: `Trace`
   - Position: At the very beginning of the `Handle` method

2. **Handler End Log**
   - Format: `"{HandlerName} ends"`
   - Log level: `Trace`
   - Position: Just before returning from the `Handle` method (or in a finally block)

3. **Implementation Options**
   - Option A: Add logging directly in each handler
   - Option B: Create a MediatR pipeline behavior for cross-cutting logging concerns (recommended)

4. **Example Pipeline Behavior**
```csharp
   public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
   {
       public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
       {
           var handlerName = typeof(TRequest).Name;
           _logger.LogTrace("{HandlerName} starts", handlerName);
           try
           {
               return await next();
           }
           finally
           {
               _logger.LogTrace("{HandlerName} ends", handlerName);
           }
       }
   }
```

### Domain Entity Logging

Add informational logs within domain entities to capture meaningful business events:

1. **Analysis Requirements**
   - Review all domain entities and their behavioral methods
   - Identify significant state transitions and business events
   - Determine what information is meaningful for troubleshooting and business analytics

2. **Logging Guidelines**
   - **Log level**: Use `LogInformation` for business events
   - **Message format**: Concise yet descriptive
   - **Structured data**: Use structured logging with named properties, not string interpolation
   - **Examples of events to log**:
     - Trip reaches a checkpoint: `"Trip reached checkpoint {CheckpointName} ({CheckpointId})"`
     - Trip receives an event: `"Trip received event {EventType}"`
     - Status changes: `"Trip status changed from {OldStatus} to {NewStatus}"`
     - Incident occurrence: `"Incident occurred: {IncidentType} - {IncidentSeverity}"`
     - Vehicle assignment: `"Vehicle {VehicleId} assigned to Trip {TripId}"`

3. **Best Practices**
   - Don't log in tight loops or high-frequency operations
   - Use consistent property names across the application
   - Include relevant entity IDs for correlation

4. **Example Domain Logging**
```csharp
   public void ReachCheckpoint(Guid tripId, ReachCheckpointRequest request)
   {
       using var tripIdScope =_logger.BeginScope("TripId={TripId}", tripId);
       // Business logic
       _logger.LogInformation("Trip reached checkpoint {CheckpointName}", request.CheckpointName);
   }
```

## Implementation Checklist

- [ ] Set up OpenTelemetry SDK with metrics exporter
- [ ] Implement endpoint performance histogram metrics with P50/P95/P99
- [ ] Create trip processing counter
- [ ] Create incident counter with type labels
- [ ] Create event processing counter
- [ ] Configure environment-specific logging (plain text for dev, JSON for staging/prod)
- [ ] Add logging scopes at endpoint level for all domain entity IDs
- [ ] Implement MediatR pipeline logging behavior or add logs to handlers
- [ ] Audit domain entities and add structured informational logs for business events
- [ ] Document metric names, labels, and logging conventions for the team in Observability section of README.md

## Additional Considerations

- Ensure OpenTelemetry exporters are configured for your observability backend (e.g. Application Insights)
- Consider implementing distributed tracing alongside metrics and logs for complete observability
- Regularly review and refine what is being logged based on operational needs