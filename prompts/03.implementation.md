**Role:** Senior C# Developer & Tech Lead
**Task:** Implement the "SpaceTruckers" Core Domain and Application layer based on the analysis provided.

**Context:**
We are using Clean Architecture with DDD Event-Driven principles. We prioritize Domain purity, Testability, and Concurrency handling.
Using the environment from Prompt 1 and the requirements from Prompt 2, implement the core backend.

**Architectural Guidelines:**
- **Pattern:** Clean Architecture (Onion) with CQRS.
  - `Core` (Domain Entities, Value Objects, Domain Events).
  - `Application` (Use Cases/Command Handlers using MediatR, make it easy to switch to external persistant message brokers in the future).
  - `Infrastructure` (In-Memory thread safe repositories for simplicity, but strictly decoupled behind interfaces, so it is possible to switch to EFCore in the future).
  - `Api` (Minimal entry point, FluentValidation to validate api input).
- **Concurrency:** Implement **Optimistic Concurrency Control** (using a Version/ETag) on the `Trip` aggregate to satisfy the `concurrency_control.feature` scenarios.
- **Domain Events:** The system must be event-driven. State changes in `Trip` must publish events (e.g., `TripStarted`, `IncidentOccurred`).

**Instructions:**

1.  **Domain Layer Implementation (C#):**
    * Create the `Trip` Aggregate Root.
    * Implement **Optimistic Concurrency** (add a `Version` property).
    * Implement logic to satisfy the Gherkin scenarios defined previously in `tests/acceptance/features/*.feature` files.
    * Ensure all state changes emit **Domain Events** (e.g., `TripStarted`, `IncidentReported`).
    * Use `StronglyTypedIds` (e.g., `TripId`, `DriverId`) to prevent primitive obsession.
    * Use Guid Version 7 as id values.
    * Implement a `TripRepository` (In-Memory) that simulates concurrency conflicts if versions do not match.
    * Do not put endoints content into one Program.cs file:
        - Use separate static classes for each endpoints as extension methods.
        - Keep handlers as private static methods in the same class for better performance.
        - Use MapGroup to avoid repeating route prefixes and share common configuration.
        - Add OpenAPI/Swagger tags using .WithTags() for documentation
    * Remove empty classes

2.  **C4 Diagrams (Structurizr DSL):**
    * Update the `workspace.dsl` to reflect the implementation details.
    * **Component View:** Show how the `TripCommandHandlers` interact with the `TripRepository` and `DomainEventPublisher`.
    * **Dynamic View** Visualize the flow of the "Start Trip" command:
        - User -> API -> CommandHandler -> Repository (Load) -> Aggregate (Logic) -> Repository (Save) -> EventBus (Publish).

3.  **Tests (xUnit):**
    * **Unit Tests:**
      - Generate tests for the `Trip` Aggregate covering the Invariants (e.g., cannot start without driver).
      - Generate tests to cover scenarios defined in `tests/acceptance/features/*.feature` files
      - Ensure at least 85% of code coverage for domain and application levels.
    * **Integration Tests:** 
        - Generate a test that maps to the "Concurrency" Gherkin scenario. It should simulate two parallel requests trying to modify the same aggregate to prove the Optimistic Concurrency mechanism works.
        - Generate integration tests for each API endpoint and ensure api responded with correct responses for each scenarios defined in `tests/acceptance/features/*.feature` files
    * **Clean up** Remove empty test classes

4.  **Documentation:**
    * Write an ADR `docs/structurizr/adrs/0001-clean-architecture.md` to declare and explain why we use clean architecture over other approaches
    * Write an ADR `docs/structurizr/adrs/0002-domain-events-dispatch.md` to declare and explain why we use event-driven approach and MediatR over other approaches and libraries, for example, .Net channels. Explain why it is easy to switch from MediatR to external persistant message brokers like Kafka or AWS SQS.
    * Write an ADR `docs/structurizr/adrs/0003-use-in-memory-persistence-strategy.md` to declare and explain why we use in-memory thread safe approach over storing data in the database with EFCore. Explain why it is easy to switch to EFCore in the future when needed.
    * Write an ADR `docs/structurizr/adrs/0004-concurrency.md` explaining *why* we chose Optimistic Concurrency over Pessimistic Locking for this specific domain.

**Constraint:**
Do not implement the full Infrastructure (SQL Database) yet. Use an `InMemoryRepository` to make the solution runnable immediately, but ensure the interfaces (`ITripRepository`) are defined so we can swap it for EF Core later.

**Output:**
Provide the C# classes, the updated Structurizr DSL, the Test classes, and the ADR markdown file. Ensure the code adheres to the `.editorconfig` and `Directory.Build.props` settings defined earlier.
